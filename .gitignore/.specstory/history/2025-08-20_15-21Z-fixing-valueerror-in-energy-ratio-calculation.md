<!-- Generated by SpecStory -->

# Fixing ValueError in energy ratio calculation (2025-08-20 15:21Z)

_**User**_

ValueError                                Traceback (most recent call last)
Cell In[14], line 24
     22 OA = OA_energy_ratio(J_true, alpha)
     23 dcrr_ratio = DCRR_energy_ratio(J_true, m, alpha)
---> 24 yds_m_ratio = yds_m_energy_ratio(J_true, m, alpha)
     25 print("AVG = ", AVR)
     26 y_AVR.append(AVR)

Cell In[4], line 3, in yds_m_energy_ratio(_J, m, alpha)
      1 def yds_m_energy_ratio(_J, m, alpha):
      2     J = copy.deepcopy(_J)
----> 3     yds_speed_list = yds_M(J, m)
      4     energy_yds_m = computeEnergy(yds_speed_list, alpha)
      6     J = copy.deepcopy(_J)

File c:\Users\visha\OneDrive\Desktop\SWP_M\source\scheduling_algorithms.py:259, in yds_M(J, m)
    257         sub_J[job_id] = J[job_id]
    258     speed_i = Optimal_Alg(sub_J)
--> 259     speed.update(speed_i)
    260 return speed

ValueError: dictionary update sequence element #0 has length 15; 2 is required

---

_**Assistant**_



---

I see you're encountering a `ValueError` related to updating a dictionary. It seems like the `Optimal_Alg` function is returning a value that isn't compatible with `dictionary.update()`, which expects a sequence of key-value pairs.

To resolve this, I need to examine the implementation of `yds_M` and `Optimal_Alg` in `source/scheduling_algorithms.py`. I'll start by reading the relevant parts of that file.

---

Read file: undefined

---



---

I see the error is occurring on line 259 in `source/scheduling_algorithms.py`, where `speed.update(speed_i)` is called. The error message "dictionary update sequence element #0 has length 15; 2 is required" indicates that `speed_i`, which is the return value of `Optimal_Alg(sub_J)`, is not a dictionary or an iterable of key-value pairs (2-element tuples/lists). Instead, it appears to be an iterable where each element has 15 items.

To understand why `Optimal_Alg` is returning this unexpected format, I need to examine its definition. I will now search for `Optimal_Alg` in `source/scheduling_algorithms.py`.

---



---

Now I know that `Optimal_Alg` is defined on line 137 in `source/scheduling_algorithms.py`. I'll read the definition of the function `Optimal_Alg` to understand what it's supposed to return.

---

Read file: undefined

---

I have identified the issue. The `Optimal_Alg` function on line 137 of `source/scheduling_algorithms.py` returns *two* values: `speed_list_dictionary` and `J_sol`.

However, the line 258 `speed_i = Optimal_Alg(sub_J)` in `yds_M` is attempting to unpack these two return values into a single variable `speed_i`. This means `speed_i` becomes a tuple containing both the dictionary and `J_sol`. When `speed.update(speed_i)` is then called, it tries to interpret this tuple as a sequence of key-value pairs, leading to the `ValueError`.

To fix this, I need to modify line 258 to correctly unpack the two return values from `Optimal_Alg`. I only need `speed_list_dictionary` for the `update` call, so I'll discard `J_sol` using an underscore.

---

<details><summary>Edit file: source/scheduling_algorithms.py</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -256,5 +256,5 @@
          for job_id in job_list:
              sub_J[job_id] = J[job_id]
-         speed_i = Optimal_Alg(sub_J)
+         speed_i, _ = Optimal_Alg(sub_J)
          speed.update(speed_i)
      return speed
```

</details>

---

I have applied the fix to `source/scheduling_algorithms.py`. Now, the `Optimal_Alg` function's return values are correctly unpacked, and `speed_i` will be the dictionary that `speed.update()` expects.

I'm done with the changes, I'll now run `read_lints` to check if I've introduced any new errors.

---



---

I've fixed the `ValueError` and verified that no new linter errors were introduced.

If you'd like, you can try running your code again to confirm the fix, or let me know if there's anything else I can help with!

---

